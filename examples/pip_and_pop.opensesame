# Generated by OpenSesame 0.27~pre16 (Frisky Freud)
# Sat Oct 13 19:26:03 2012 (posix)
# <http://www.cogsci.nl/opensesame>

set foreground "white"
set subject_parity "even"
set description "A multisensory integration paradigm based on Van der Burg et al. (2008) JEP HPP"
set title "Pip & Pop"
set compensation "0"
set coordinates "relative"
set height "768"
set mouse_backend "psycho"
set width "1024"
set sampler_backend "legacy"
set sound_buf_size "1024"
set keyboard_backend "psycho"
set background "black"
set subject_nr "0"
set psychopy_wintype "pyglet"
set sound_sample_size "-16"
set start "experiment"
set synth_backend "legacy"
set canvas_backend "psycho"

define feedback feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -96 "Your average response time was [avg_rt]ms" center=1 color=white font_family=mono font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 32 "Press any key to continue" center=1 color=white font_family=mono font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 -32 "Your accuracy was [acc]%" center=1 color=white font_family=mono font_size=18 font_italic=no font_bold=no show_if="always"

define text_display end_of_experiment
	set foreground "white"
	set font_size "18"
	set description "Presents a display consisting of text"
	set maxchar "50"
	set align "center"
	__content__
	END OF EXPERIMENT
	
	Press any key to exit ...
	__end__
	set background "black"
	set duration "keypress"
	set font_family "mono"

define notepad about_this_experiment
	__note__
	This experiment is based on the "Pip & Pop" studies by Erik van der Burg and Chris Olivers.
	The basic finding is that you are much quicker to find a target, when each color change of
	the target is accompanied by a sound.
	
	For more information, please visit:
	http://www.psy.vu.nl/pippop/
	
	---
	Sebastiaan MathU+00F4t
	__end__
	set description "A simple notepad to document your experiment. This plug-in does nothing."

define loop block_loop
	set repeat "3"
	set description "A single block of trials"
	set item "trial_sequence"
	set column_order "correct_response;ori_target;n_dist"
	set cycles "6"
	set order "random"
	setcycle 0 correct_response "slash"
	setcycle 0 n_dist "24"
	setcycle 0 ori_target "0"
	setcycle 1 correct_response "z"
	setcycle 1 n_dist "24"
	setcycle 1 ori_target "90"
	setcycle 2 correct_response "slash"
	setcycle 2 n_dist "36"
	setcycle 2 ori_target "0"
	setcycle 3 correct_response "z"
	setcycle 3 n_dist "36"
	setcycle 3 ori_target "90"
	setcycle 4 correct_response "slash"
	setcycle 4 n_dist "48"
	setcycle 4 ori_target "0"
	setcycle 5 correct_response "z"
	setcycle 5 n_dist "48"
	setcycle 5 ori_target "90"
	run trial_sequence

define form_text_display form_instructions
	set rows "1;4;1"
	set description "A simple text display form"
	__form_text__
	You will see a lot of shapes of different orientations. One of these shapes (the target) is vertical or horizontal. All of the other shapes (the distractors) have different orientations, and are never horizontal or vertical.
	
	The colors of the shapes are irrelevant. The short, high beeps are also irrelevant.
	
	Your task is to find the shape that is either horizontal or vertical and then indicate its orientation. Note that this is not always easy, sometimes you will really have to search for it!
	
	- horizontal -> 'z' key
	- vertical -> 'slash' key
	
	Be as fast and accurate as possible! If you make a mistake you will hear a long, low beep.
	__end__
	set cols "1;1;1"
	set form_title "<span size=24>Instructions</span>"
	set ok_text "Start practice!"
	widget 0 0 3 1 label text="[form_title]"
	widget 0 1 3 1 label center="no" text="[form_text]"
	widget 1 2 1 1 button text="[ok_text]"


define inline_script dynamic_search_display
	___run__
	from openexp.synth import synth
	from openexp.keyboard import keyboard
	from psychopy.visual import PatchStim
	from random import randint, choice, sample
	from math import sqrt
	
	n_dist = self.get("n_dist") # Nr of distractors
	margin = 100 # Margin from the screen borders
	ori_target = self.get("ori_target") # Orientation of the target
	ori_dist = 30, 60, 120, 150 # Possible distractor orientations
	min_d = 64 # Minimum distance between stimuli
	size = 16, 64 # Size of the stimuli
	speed = 150 # Flickering speed
	target_chance = 10 # How often is the target selected
	min_target_interval = 150 # The minimum interval between two target flips
	min_t = 500 # The target is not allowed to flip before 500ms after the trial start
	
	sound = self.get("sound") == "yes"
	xmin = margin-self.get("width")/2
	xmax = self.get("width")/2-margin
	ymin = margin-self.get("height")/2
	ymax = self.get("height")/2-margin
	colors = "red", "green"
	
	# Draw and remember the fixation dot
	stim = PatchStim(self.experiment.window, tex=None, mask="circle", pos=(0,0), size=16, color="white")
	fixdot = stim,0,0,None,None
	stim.draw()
	self.experiment.window.flip()
	self.sleep(500)
	
	# Generate a list of orientations and positions
	l_stim = [] # List of all stimuli
	for i in range(n_dist):
	
		# Pick an orientation
		if i == 0:
			ori = ori_target
		else:
			ori = choice(ori_dist)
			
		# Pick a color:
		col = choice(colors)
			
		# Pick an available position on the screen
		redo = True
		while redo:
			x = randint(xmin, xmax)
			y = randint(ymin, ymax)
			redo = False
			for _stim,_x,_y,_ori,_col in l_stim+[fixdot]:
				d = sqrt( (_x-x)**2 + (_y-y)**2 )
				if d < min_d:
					redo = True
					break
		
		# Generate and save the stimulus			
		stim = PatchStim(self.experiment.window, tex=None, mask="gauss", pos=(x,y), size=size, ori=ori, color=col)
		l_stim.append( (stim,x,y,ori,col) )
		
	my_keyboard = keyboard(self.experiment, timeout=5)
	my_keyboard.flush()
	my_synth = synth(self.experiment)
	
	sri = self.time()
	last_target_flip = self.time() + min_t
	while True:
	
		t = self.time()
		
		# The nr of flips is a maximum of 1/7 times the
		# nr of distractors. This is roughly comparable
		# to the Van der Burg et al. paradigm
		n_flip = randint(1, (n_dist+1)/7)
		
		# The target is allowed to flip
		if t-last_target_flip > min_target_interval:
		
			# Select a random set of stimuli to flip. If the target
			# is selected (0), the target is the only stimulus to flip
			l_flip = sample(range(0, n_dist), n_flip)
			
			# Target is selected!
			if 0 in l_flip:
				l_flip = [0]
				last_target_flip = t
		
		# The target is not allowed to flip
		else:	
			l_flip = sample(range(1, n_dist), n_flip)
			
		# Flip the color of the choosen stimuli
		for i in l_flip:
			stim, x, y, ori, col = l_stim[i]
			if col == colors[0]:
				col = colors[1]
			else:
				col = colors[0]
			stim.setColor(col)
			l_stim[i] = stim,x,y,ori,col
		
		# Draw all stimuli
		for stim,x,y,ori,col in l_stim+[fixdot]:
			stim.draw()
		# Optionally play a sound if the target has been swapped
		if i == 0 and sound:
			my_synth.play()
		self.experiment.window.flip()	
		
		# Poll the keyboard and break out after a fixed duration (speed)
		resp = None
		while self.time() - t < speed and resp == None:
			resp, time = my_keyboard.get_key()
			if resp != None:
				break			
		if resp != None:
			break			
					
	# Clear the window
	fixdot[0].draw()
	self.experiment.window.flip()
	
	response = my_keyboard.to_chr(resp)
	response_time = time-sri
	if response == self.get("correct_response"):
		correct = 1
	else:
		correct = 0
	self.experiment.set("response", response)
	self.experiment.set("response_time", response_time)
	self.experiment.set("correct", correct)
	
	# Maintain feedback data
	self.experiment.total_response_time += response_time
	self.experiment.total_responses += 1
	self.experiment.total_correct += correct
	self.experiment.acc = 100.0 * self.experiment.total_correct / self.experiment.total_responses
	self.experiment.avg_rt = self.experiment.total_response_time / self.experiment.total_responses
	__end__
	set _prepare ""
	set description "Executes Python code"

define text_display end_of_practice
	set foreground "white"
	set font_size "18"
	set description "Presents a display consisting of text"
	set maxchar "50"
	set align "center"
	__content__
	END OF PRACTICE
	
	Press any key to start the experiment ...
	__end__
	set background "black"
	set duration "keypress"
	set font_family "mono"

define loop experimental_loop
	set repeat "5"
	set description "Repeatedly runs another item"
	set item "block_sequence"
	set column_order "practice;sound"
	set cycles "2"
	set order "random"
	setcycle 0 sound "yes"
	setcycle 0 practice "no"
	setcycle 1 sound "no"
	setcycle 1 practice "no"
	run block_sequence

define sequence experiment
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run about_this_experiment "always"
	run form_sound_test_1 "always"
	run sound_test "always"
	run form_sound_test_2 "always"
	run form_instructions "always"
	run practice_loop "always"
	run end_of_practice "always"
	run experimental_loop "always"
	run end_of_experiment "always"

define fixation_dot fixation_dot
	set foreground "white"
	set style "cross-small"
	set description "Presents a central fixation dot with a choice of various styles"
	set y "0"
	set background "black"
	set duration "750"
	set x "0"
	set penwidth "3"

define synth synth
	set description "A basic sound synthesizer"
	set decay "5"
	set attack "0"
	set volume "1"
	set length "500"
	set duration "sound"
	set freq "220"
	set osc "sine"
	set pan "0"

define logger logger
	set ignore_missing "no"
	set description "Logs experimental data"
	set auto_log "no"
	log "response"
	log "correct"
	log "response_time"
	log "correct_response"
	log "n_dist"
	log "ori_target"
	log "count_experiment"
	log "sound"
	log "practice"
	log "count_trial_sequence"
	log "count_block_sequence"

define sequence block_sequence
	set flush_keyboard "yes"
	set description "A sequence containging a single block of trials followed by feedback to the participant"
	run reset_feedback "always"
	run block_loop "always"
	run feedback "always"

define loop practice_loop
	set repeat "1"
	set description "A loop containing one or more practice blocks"
	set item "block_sequence"
	set column_order "practice;sound"
	set cycles "1"
	set order "random"
	setcycle 0 sound "yes"
	setcycle 0 practice "yes"
	run block_sequence

define synth sound_test
	set description "A basic sound synthesizer"
	set decay "5"
	set attack "0"
	set volume "1"
	set length "1000"
	set duration "sound"
	set freq "440"
	set osc "sine"
	set pan "0"

define form_text_display form_sound_test_1
	set rows "1;4;1"
	set description "A simple text display form"
	__form_text__
	If you click the button below, you should hear a beep.
	
	If you don't, please make sure that the sound is turned on.
	__end__
	set cols "1;1;1"
	set form_title "<span size=24>Sound test</span>"
	set ok_text "Test!"
	widget 0 0 3 1 label text="[form_title]"
	widget 0 1 3 1 label center="no" text="[form_text]"
	widget 1 2 1 1 button text="[ok_text]"


define form_text_display form_sound_test_2
	set rows "1;4;1"
	set description "A simple text display form"
	__form_text__
	Did you hear a sound?
	
	If you didn't, please make sure that the sound is turned on.
	__end__
	set cols "1;1;1"
	set form_title "<span size=24>Sound test</span>"
	set ok_text "Continue to instructions"
	widget 0 0 3 1 label text="[form_title]"
	widget 0 1 3 1 label center="no" text="[form_text]"
	widget 1 2 1 1 button text="[ok_text]"


define sequence trial_sequence
	set flush_keyboard "yes"
	set description "A single trial"
	run fixation_dot "always"
	run dynamic_search_display "always"
	run synth "[correct] = 0"
	run logger "always"

define reset_feedback reset_feedback

