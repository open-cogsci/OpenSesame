# Generated by OpenSesame 2.9.5~pre1 (Hesitant Heisenberg)
# Mon Mar  2 14:09:07 2015 (posix)
# <http://www.cogsci.nl/opensesame>

set background "black"
set canvas_backend "legacy"
set compensation "0"
set coordinates "relative"
set description "A visual search task based on Horowitz and Wolfe (1998, Nature)"
set font_bold "no"
set font_family "mono"
set font_italic "no"
set font_size "18"
set foreground "white"
set height "768"
set keyboard_backend "legacy"
set mouse_backend "legacy"
set sampler_backend "legacy"
set start "experiment"
set subject_nr "0"
set subject_parity "even"
set synth_backend "legacy"
set title "Visual search has no memory"
set transparent_variables "no"
set width "1024"

define notepad about_this_experiment
	set description "A simple notepad to document your experiment. This plug-in does nothing."
	__note__
	This experiment is loosely based on the study by Horowitz and Wolfe, in which
	they showed that if you move stimuli around in a visual search display, reaction
	times are not very much affected.
	Horowitz, T. S., & Wolfe, J. M. (1998). Visual search has no memory. Nature, 394(6693), 575-577. doi:10.1038/29068
	Feel free to use this experiment as a template for creating your own.
	--
	Sebastiaan
	--
	This file is part of OpenSesame.
	OpenSesame is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	OpenSesame is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	You should have received a copy of the GNU General Public License
	along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
	__end__

define loop block_loop
	set column_order "shuffle;set_size;target"
	set cycles "12"
	set description "Repeatedly runs another item"
	set item "trial_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 set_size "8"
	setcycle 0 shuffle "yes"
	setcycle 0 target "absent"
	setcycle 1 set_size "8"
	setcycle 1 shuffle "yes"
	setcycle 1 target "present"
	setcycle 2 set_size "8"
	setcycle 2 shuffle "no"
	setcycle 2 target "absent"
	setcycle 3 set_size "8"
	setcycle 3 shuffle "no"
	setcycle 3 target "present"
	setcycle 4 set_size "12"
	setcycle 4 shuffle "yes"
	setcycle 4 target "absent"
	setcycle 5 set_size "12"
	setcycle 5 shuffle "yes"
	setcycle 5 target "present"
	setcycle 6 set_size "12"
	setcycle 6 shuffle "no"
	setcycle 6 target "absent"
	setcycle 7 set_size "12"
	setcycle 7 shuffle "no"
	setcycle 7 target "present"
	setcycle 8 set_size "16"
	setcycle 8 shuffle "yes"
	setcycle 8 target "absent"
	setcycle 9 set_size "16"
	setcycle 9 shuffle "yes"
	setcycle 9 target "present"
	setcycle 10 set_size "16"
	setcycle 10 shuffle "no"
	setcycle 10 target "absent"
	setcycle 11 set_size "16"
	setcycle 11 shuffle "no"
	setcycle 11 target "present"
	run trial_sequence

define sequence block_sequence
	set description "Runs a number of items in sequence"
	run reset_feedback "always"
	run block_loop "always"
	run feedback "always"

define sketchpad correct
	set description "Displays stimuli"
	set duration "500"
	set start_response_interval "no"
	draw fixdot 0 0 color="green" style="default" z_index=0 show_if="always"

define sketchpad end_of_experiment
	set description "Displays stimuli"
	set duration "keypress"
	set start_response_interval "no"
	draw textline 0 -64 "The experiment is finished!" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 0 "Thank you for participating" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 64 "Press any key to exit the experiment" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sketchpad end_of_practice
	set description "Displays stimuli"
	set duration "keypress"
	set start_response_interval "no"
	draw textline 0 -192 "The practice block is finished" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 -128 "You will no longer receive feedback after each trial" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 0 "Press any key to continue!" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define sequence experiment
	run about_this_experiment "always"
	run instructions "always"
	run practice_loop "always"
	run end_of_practice "always"
	run experimental_loop "always"
	run end_of_experiment "always"

define loop experimental_loop
	set column_order "practice"
	set cycles "1"
	set description "Repeatedly runs another item"
	set item "block_sequence"
	set order "random"
	set repeat "2"
	setcycle 0 practice "no"
	run block_sequence

define feedback feedback
	set description "Provides feedback to the participant"
	set duration "keypress"
	draw textline 0 -96 "Your average response time was [avg_rt]ms" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 -32 "Your accuracy was [acc]%" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 64 "Press any key to continue!" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define fixation_dot fixation_dot
	set background "black"
	set description "Presents a central fixation dot with a choice of various styles"
	set duration "500"
	set foreground "white"
	set penwidth "3"
	set style "cross"

define sketchpad graydot
	set description "Displays stimuli"
	set duration "500"
	set start_response_interval "no"
	draw fixdot 0 0 color="white" style="default" z_index=0 show_if="always"

define sketchpad incorrect
	set description "Displays stimuli"
	set duration "500"
	set start_response_interval "no"
	draw fixdot 0 0 color="red" style="default" z_index=0 show_if="always"

define sketchpad instructions
	set description "Displays stimuli"
	set duration "keypress"
	set reset_variables "no"
	set start_response_interval "no"
	draw textline 0 256 "Press any key to begin with a practice block!" center=1 color="white" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw line 32 128 96 128 color="white" penwidth=3 z_index=0 show_if="always"
	draw line 96 96 96 160 color="white" penwidth=3 z_index=0 show_if="always"
	draw line 160 96 224 96 color="white" penwidth=3 z_index=0 show_if="always"
	draw line 192 96 192 160 color="white" penwidth=3 z_index=0 show_if="always"
	draw line -32 128 -96 128 color="white" penwidth=3 z_index=0 show_if="always"
	draw line -96 96 -96 160 color="white" penwidth=3 z_index=0 show_if="always"
	draw line -192 96 -192 160 color="white" penwidth=3 z_index=0 show_if="always"
	draw line -224 160 -160 160 color="white" penwidth=3 z_index=0 show_if="always"
	draw textline 0.0 -160.0 "Your goal is to indicate as quickly as possible<br />if a 'T' is present in the display<br />by pressing the 'Z' key if you detect a 'T'<br />and pressing the '/' key if you don't.<br /><br />A 'T' can be tilted in various ways, like:" center=1 color="white" font_family="mono" font_size=24 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define logger logger
	set auto_log "no"
	set description "Logs experimental data"
	log "shuffle"
	log "set_size"
	log "target"
	log "count_experiment"
	log "practice"
	log "count_trial_sequence"
	log "count_block_sequence"
	log "correct"
	log "response_time"
	log "response"
	log "subject_nr"

define loop practice_loop
	set column_order "practice"
	set cycles "1"
	set description "Repeatedly runs another item"
	set item "block_sequence"
	set order "random"
	set repeat "1"
	setcycle 0 practice "yes"
	run block_sequence

define reset_feedback reset_feedback

define inline_script search_display
	___prepare__
	def random_pos(self, pos_list, margin):
		"""Returns a random, but unoccupied position on the display"""
		import random
		import math
		random.seed()
		d = None
		while d == None or d < margin:
			x = random.randint(margin, self.get("width") - margin)
			y = random.randint(margin, self.get("height") - margin)
			if len(pos_list) == 0:
				break
			for _x, _y in pos_list:
				d = math.sqrt( (x - _x) ** 2 + (y - _y) ** 2)
				if d < margin:
					break
		pos_list.append( (x, y) )
		return x, y
	def draw_T(self, canvas, size, x, y):
		"""Draw a randomly rotated T"""
		import random
		r = random.choice( [0, 1, 2, 3] )
		if r == 0:
			canvas.line(x - size, y - size, x + size, y - size)
			canvas.line(x, y - size, x, y + size)
		elif r == 1:
			canvas.line(x + size, y - size, x + size, y + size)
			canvas.line(x - size, y, x + size, y)
		elif r == 2:
			canvas.line(x - size, y + size, x + size, y + size)
			canvas.line(x, y - size, x, y + size)
		else:
			canvas.line(x - size, y - size, x - size, y + size)
			canvas.line(x - size, y, x + size, y)
	def draw_L(self, canvas, size, x, y):
		"""Draw a randomly rotated L"""
		import random
		r = random.choice( [0, 1, 2, 3] )
		if r == 0:
			canvas.line(x + size, y + size, x - size, y + size)
			canvas.line(x - size, y + size, x - size, y - size)
		elif r == 1:
			canvas.line(x - size, y + size, x - size, y - size)
			canvas.line(x - size, y - size, x + size, y - size)
		elif r == 2:
			canvas.line(x - size, y - size, x + size, y - size)
			canvas.line(x + size, y - size, x + size, y + size)
		else:
			canvas.line(x + size, y - size, x + size, y + size)
			canvas.line(x + size, y + size, x - size, y + size)
	def draw_mask(self, canvas, size, x, y):
		"""Draw a mask"""
		canvas.line(x + size, y + size, x - size, y + size)
		canvas.line(x - size, y + size, x - size, y - size)
		canvas.line(x - size, y - size, x + size, y - size)
		canvas.line(x + size, y - size, x + size, y + size)
		canvas.line(x, y - size, x, y + size)
		canvas.line(x - size, y, x + size, y)
	import math
	import random
	# Store all created canvasses in two lists
	self.search_display_list = []
	self.mask_display_list = []
	# Some stimulus parameters
	max_canvas = 40
	stim_size = 20
	stim_margin = 100
	penwidth = 3
	# Create a max_canvas number of canvasses
	for i in range(max_canvas):
		# Create empty offline canvasses
		search_display = self.offline_canvas(auto_prepare=False)
		mask_display = self.offline_canvas(auto_prepare=False)
		search_display.set_penwidth(penwidth)
		mask_display.set_penwidth(penwidth)
		search_display.fixdot()
		mask_display.fixdot()
		# Draw all stimuli
		pos_list = []
		for j in range(self.get("set_size")):
			x, y = random_pos(self, pos_list, stim_margin)
			# If the target is present, the first stimulus is the target
			if self.get("target") == "present" and j == 0:
				draw_T(self, search_display, stim_size, x, y)
			else:
				draw_L(self, search_display, stim_size, x, y)
			draw_mask(self, mask_display, stim_size, x, y)
		# Add the new canvasses to the list of canvasses
		self.search_display_list.append(search_display)
		self.mask_display_list.append(mask_display)
		search_display.prepare()
		mask_display.prepare()
	__end__
	___run__
	from openexp.keyboard import keyboard
	# Create a keyboard object
	kb = keyboard(self.experiment, keylist = ["z", "slash"])
	# Mark the start of the response interval
	start_time = self.time()
	# Walk through all the displays
	for i in range(len(self.search_display_list)):
		# Show the search display
		self.search_display_list[i].show()
		# Wait for a keypress
		response, time = kb.get_key(timeout = 80)
		if response != None:
			break
		# Show the mask
		self.mask_display_list[i].show()
		# Wait for the keypress
		response, time = kb.get_key(timeout = 20)
		if response != None:
			break
	if response != None:
		# If a key was pressed, determine the response, response_time and correct variables
		response_time = time - start_time
		synonyms = kb.synonyms(response)
		if ("z" in synonyms and self.get("target") == "present") or ("slash" in synonyms and self.get("target") == "absent"):
			correct = 1
			self.experiment.set("total_correct", self.get("total_correct") + 1)
		else:
			correct = 0
	else:
		# On a timeout, mark a timeout response
		correct = 0
		response_time = self.time() - start_time
		response = "timeout"
	# Do some bookkeeping so we can give feedback in the feedback item
	self.experiment.set("total_responses", self.get("total_responses") + 1)
	self.experiment.set("total_response_time", self.get("total_response_time") + response_time)
	self.experiment.set("avg_rt", self.get("total_response_time") / self.get("total_responses"))
	self.experiment.set("acc", 100.0 * self.get("total_correct") / self.get("total_responses"))
	# These variables are important for logging
	self.experiment.set("correct", correct)
	self.experiment.set("response_time", response_time)
	self.experiment.set("response", response)
	__end__
	set description "Executes Python code"

define sequence trial_sequence
	set description "Runs a number of items in sequence"
	run fixation_dot "always"
	run search_display "always"
	run graydot "[practice] = no"
	run incorrect "[correct] = 0 and [practice] = yes"
	run correct "[correct] = 1 and [practice] = yes"
	run logger "always"

